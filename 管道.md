一、管道（pipe）：半双工，只能用在父子进程间
1.创建管道：
int pipe(int fd[2]);
成功：返回0；失败：返回-1
fd[0]——读打开
fd[1]——写打开

##管道是半双工的，只提供单个方向的数据流，创建后需要主动调用close来关闭未使用的管道端；
close(int fd[0]); //关闭读端
close(int fd[1]); //关闭写端
##如果想要双向数据流，需要创建两个管道，每个方向一个

2.popen/pclose：创建一个管道、fork一个子进程、关闭未使用的管道端、执行一个Shell运行命令，然后等待命令种植
FILE* popen(const char *cmdstring, const char *type);
成功：返回文件指针；失败：返回NULL
int pclose(FILE* fp);
成功：返回cmdstring的终止状态；失败，返回-1

二、命名管道（FIFO）：支持无亲缘关系的进程交换数据，FIFO是一种文件类型，FIFO的路径名存在于文件系统中
1.创建FIFO：
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd,const char *path, mode_t mode);
成功：返回0；失败：返回-1

##两函数区别：mkfifoat可以用来在fd文件描述符表示的目录相关位置创建一个FIFO
1）若path指定绝对路径，则fd参数无效，两函数类似
2）若path指定相对路径，则fd是一个打开目录的有效文件描述符，路径名与目录有关
3）若path指定相对路径，且fd参数有特殊值AT_FDCWD，则路径名以当前目录开始，两函数类似

2.
